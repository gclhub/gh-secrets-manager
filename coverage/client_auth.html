
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">/home/runner/work/gh-secrets-manager/gh-secrets-manager/pkg/api/client.go (7.7%)</option>
				
				<option value="file1">/home/runner/work/gh-secrets-manager/gh-secrets-manager/pkg/api/repository.go (0.0%)</option>
				
				<option value="file2">/home/runner/work/gh-secrets-manager/gh-secrets-manager/pkg/api/secrets.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "strings"
        "time"

        "gh-secrets-manager/pkg/config"

        "github.com/cli/go-gh"
        "github.com/google/go-github/v45/github"
        "golang.org/x/crypto/nacl/box"
)

// Verbose controls the logging verbosity across the API package
var Verbose bool

type AuthMethod int

const (
        AuthMethodPAT AuthMethod = iota
        AuthMethodGitHubApp
)

type ClientOptions struct {
        AuthMethod     AuthMethod
        AppID          int64
        InstallationID int64
        AuthServer     string
}

type authResponse struct {
        Token     string    `json:"token"`
        ExpiresAt time.Time `json:"expires_at"`
}

type Client struct {
        github    *github.Client
        ctx       context.Context
        opts      *ClientOptions
        authToken string
        expiresAt time.Time
}

func NewClient() (*Client, error) <span class="cov0" title="0">{
        // Try to load GitHub App config first
        if Verbose </span><span class="cov0" title="0">{
                log.Printf("Loading configuration...")
        }</span>
        <span class="cov0" title="0">cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                if Verbose </span><span class="cov0" title="0">{
                        log.Printf("Failed to load config: %v, falling back to PAT auth", err)
                }</span>
                <span class="cov0" title="0">return NewClientWithOptions(&amp;ClientOptions{AuthMethod: AuthMethodPAT})</span>
        }

        // If GitHub App is configured, use it as default
        <span class="cov0" title="0">if cfg.IsGitHubAppConfigured() </span><span class="cov0" title="0">{
                if Verbose </span><span class="cov0" title="0">{
                        log.Printf("Using GitHub App authentication (app-id=%d, installation-id=%d)", cfg.AppID, cfg.InstallationID)
                }</span>
                <span class="cov0" title="0">return NewClientWithOptions(&amp;ClientOptions{
                        AuthMethod:     AuthMethodGitHubApp,
                        AppID:          cfg.AppID,
                        InstallationID: cfg.InstallationID,
                        AuthServer:     cfg.AuthServer,
                })</span>
        }

        // Only fall back to PAT if GitHub App is not configured
        <span class="cov0" title="0">if Verbose </span><span class="cov0" title="0">{
                log.Printf("GitHub App configuration not found, falling back to PAT authentication")
        }</span>
        <span class="cov0" title="0">return NewClientWithOptions(&amp;ClientOptions{AuthMethod: AuthMethodPAT})</span>
}

func NewClientWithOptions(opts *ClientOptions) (*Client, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                if Verbose </span><span class="cov0" title="0">{
                        log.Printf("No options provided, using default PAT auth")
                }</span>
                <span class="cov0" title="0">return newPATClient()</span>
        }

        <span class="cov0" title="0">switch opts.AuthMethod </span>{
        case AuthMethodPAT:<span class="cov0" title="0">
                if Verbose </span><span class="cov0" title="0">{
                        log.Printf("Using PAT authentication")
                }</span>
                <span class="cov0" title="0">return newPATClient()</span>

        case AuthMethodGitHubApp:<span class="cov0" title="0">
                if Verbose </span><span class="cov0" title="0">{
                        log.Printf("Initializing GitHub App client (auth-server=%s, app-id=%d, installation-id=%d)",
                                opts.AuthServer, opts.AppID, opts.InstallationID)
                }</span>
                <span class="cov0" title="0">client := &amp;Client{
                        ctx:    context.Background(),
                        github: github.NewClient(&amp;http.Client{}),
                        opts:   opts,
                }

                // Get initial token
                if err := client.refreshToken(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to get initial GitHub App token: %v", err)
                        return nil, fmt.Errorf("failed to get initial token: %w", err)
                }</span>
                <span class="cov0" title="0">log.Printf("Successfully obtained GitHub App token, expires at %s", client.expiresAt)

                // Update GitHub client with the token
                client.github = github.NewClient(&amp;http.Client{
                        Transport: &amp;authorizedTransport{
                                token: client.authToken,
                        },
                })

                return client, nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported authentication method")</span>
        }
}

type restTransport struct {
        client any // gh.RESTClient interface
}

func (t *restTransport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        // gh.RESTClient implements a Do method that handles auth
        if client, ok := t.client.(interface {
                Do(*http.Request) (*http.Response, error)
        }); ok </span><span class="cov0" title="0">{
                return client.Do(req)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("invalid REST client type")</span>
}

func newPATClient() (*Client, error) <span class="cov0" title="0">{
        // Use gh CLI's built-in REST client which handles auth
        restClient, err := gh.RESTClient(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GitHub client: %w", err)
        }</span>

        // Create a transport that uses the REST client directly
        <span class="cov0" title="0">httpClient := &amp;http.Client{
                Transport: &amp;restTransport{
                        client: restClient,
                },
        }

        return &amp;Client{
                github: github.NewClient(httpClient),
                ctx:    context.Background(),
                opts:   &amp;ClientOptions{AuthMethod: AuthMethodPAT},
        }, nil</span>
}

func (c *Client) refreshToken() error <span class="cov8" title="1">{
        if c.opts.AuthServer == "" </span><span class="cov0" title="0">{
                if Verbose </span><span class="cov0" title="0">{
                        log.Printf("No auth server URL provided")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("auth server URL is required")</span>
        }

        // Clean up auth server URL by trimming trailing slash
        <span class="cov8" title="1">authServer := strings.TrimRight(c.opts.AuthServer, "/")
        tokenURL := fmt.Sprintf("%s/token", authServer)
        if Verbose </span><span class="cov0" title="0">{
                log.Printf("Requesting token from auth server: %s", tokenURL)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", tokenURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                if Verbose </span><span class="cov0" title="0">{
                        log.Printf("Failed to create auth request: %v", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to create auth request: %w", err)</span>
        }

        <span class="cov8" title="1">q := req.URL.Query()
        q.Add("app-id", fmt.Sprintf("%d", c.opts.AppID))
        q.Add("installation-id", fmt.Sprintf("%d", c.opts.InstallationID))
        req.URL.RawQuery = q.Encode()

        if Verbose </span><span class="cov0" title="0">{
                log.Printf("Making request to auth server with URL: %s", req.URL.String())
        }</span>
        <span class="cov8" title="1">resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                if Verbose </span><span class="cov0" title="0">{
                        log.Printf("Failed to get token from auth server: %v", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get token from auth server: %w", err)</span>
        }
        <span class="cov8" title="1">defer resp.Body.Close()

        if Verbose </span><span class="cov0" title="0">{
                log.Printf("Auth server response status: %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                if Verbose </span><span class="cov0" title="0">{
                        log.Printf("Auth server error response: %s", string(bodyBytes))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("auth server returned status %d: %s", resp.StatusCode, string(bodyBytes))</span>
        }

        <span class="cov8" title="1">var authResp authResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;authResp); err != nil </span><span class="cov0" title="0">{
                if Verbose </span><span class="cov0" title="0">{
                        log.Printf("Failed to decode auth response: %v", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to decode auth response: %w", err)</span>
        }

        <span class="cov8" title="1">if Verbose </span><span class="cov0" title="0">{
                log.Printf("Successfully obtained new token, expires at: %s", authResp.ExpiresAt)
        }</span>
        <span class="cov8" title="1">c.authToken = authResp.Token
        c.expiresAt = authResp.ExpiresAt

        // Update the GitHub client with the new token
        c.github = github.NewClient(&amp;http.Client{
                Transport: &amp;authorizedTransport{
                        token: c.authToken,
                },
        })

        return nil</span>
}

type authorizedTransport struct {
        token string
}

func (t *authorizedTransport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        req.Header.Set("Authorization", "Bearer "+t.token)
        req.Header.Set("Accept", "application/vnd.github.v3+json")
        // Add User-Agent as required by GitHub API
        if req.Header.Get("User-Agent") == "" </span><span class="cov0" title="0">{
                req.Header.Set("User-Agent", "gh-secrets-manager")
        }</span>
        <span class="cov0" title="0">return http.DefaultTransport.RoundTrip(req)</span>
}

func (c *Client) ensureValidToken() error <span class="cov8" title="1">{
        if c.opts.AuthMethod != AuthMethodGitHubApp </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Refresh token if it's expired or will expire in the next minute
        <span class="cov8" title="1">if time.Now().Add(time.Minute).After(c.expiresAt) </span><span class="cov8" title="1">{
                if Verbose </span><span class="cov0" title="0">{
                        log.Printf("Token expired or will expire soon (expires at: %s), refreshing", c.expiresAt)
                }</span>
                <span class="cov8" title="1">if err := c.refreshToken(); err != nil </span><span class="cov0" title="0">{
                        if Verbose </span><span class="cov0" title="0">{
                                log.Printf("Failed to refresh token: %v", err)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to refresh token: %w", err)</span>
                }
                <span class="cov8" title="1">if Verbose </span><span class="cov0" title="0">{
                        log.Printf("Successfully refreshed token, new expiry: %s", c.expiresAt)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Variable represents a GitHub Actions variable
type Variable struct {
        Name  string `json:"name"`
        Value string `json:"value"`
}

// Secrets methods
func (c *Client) ListOrgSecrets(org string) ([]*github.Secret, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("orgs/%s/actions/secrets", org)
        req, err := c.github.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var response struct {
                Secrets []*github.Secret `json:"secrets"`
        }
        _, err = c.github.Do(c.ctx, req, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list organization secrets: %w", err)
        }</span>
        <span class="cov0" title="0">return response.Secrets, nil</span>
}

func (c *Client) ListRepoSecrets(owner, repo string) ([]*github.Secret, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">secrets, _, err := c.github.Actions.ListRepoSecrets(c.ctx, owner, repo, &amp;github.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list repository secrets: %w", err)
        }</span>
        <span class="cov0" title="0">return secrets.Secrets, nil</span>
}

func (c *Client) CreateOrUpdateOrgSecret(org string, secret *github.EncryptedSecret) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encryption, err := c.GetOrgPublicKey(org)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encryptedSecret, err := encryption.CreateEncryptedSecret(secret.Name, secret.EncryptedValue)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Custom implementation that uses github.Client's underlying HTTP client
        // instead of using github.Actions.CreateOrUpdateOrgSecret
        <span class="cov0" title="0">url := fmt.Sprintf("orgs/%s/actions/secrets/%s", org, encryptedSecret.Name)
        req := struct {
                EncryptedValue string `json:"encrypted_value"`
                KeyID          string `json:"key_id"`
        }{
                EncryptedValue: encryptedSecret.EncryptedValue,
                KeyID:          encryptedSecret.KeyID,
        }

        httpReq, err := c.github.NewRequest("PUT", url, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, httpReq, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create/update organization secret: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) CreateOrUpdateRepoSecret(owner, repo string, secret *github.EncryptedSecret) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encryption, err := c.GetRepoPublicKey(owner, repo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encryptedSecret, err := encryption.CreateEncryptedSecret(secret.Name, secret.EncryptedValue)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Custom implementation that uses github.Client's underlying HTTP client
        // instead of using github.Actions.CreateOrUpdateRepoSecret
        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/actions/secrets/%s", owner, repo, encryptedSecret.Name)
        req := struct {
                EncryptedValue string `json:"encrypted_value"`
                KeyID          string `json:"key_id"`
        }{
                EncryptedValue: encryptedSecret.EncryptedValue,
                KeyID:          encryptedSecret.KeyID,
        }

        httpReq, err := c.github.NewRequest("PUT", url, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, httpReq, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create/update repository secret: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) DeleteOrgSecret(org, secretName string) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Custom implementation that uses github.Client's underlying HTTP client
        // instead of using github.Actions.DeleteOrgSecret
        <span class="cov0" title="0">url := fmt.Sprintf("orgs/%s/actions/secrets/%s", org, secretName)
        req, err := c.github.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete organization secret: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) DeleteRepoSecret(owner, repo, secretName string) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Custom implementation that uses github.Client's underlying HTTP client
        // instead of using github.Actions.DeleteRepoSecret
        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/actions/secrets/%s", owner, repo, secretName)
        req, err := c.github.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete repository secret: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Variables methods - implemented using custom API calls since the go-github library
// doesn't support variables yet
func (c *Client) ListOrgVariables(org string) ([]*Variable, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := c.github.NewRequest("GET", fmt.Sprintf("orgs/%s/actions/variables", org), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var response struct {
                Variables []*Variable `json:"variables"`
        }
        _, err = c.github.Do(c.ctx, req, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list organization variables: %w", err)
        }</span>

        <span class="cov0" title="0">return response.Variables, nil</span>
}

func (c *Client) ListRepoVariables(owner, repo string) ([]*Variable, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := c.github.NewRequest("GET", fmt.Sprintf("repos/%s/%s/actions/variables", owner, repo), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var response struct {
                Variables []*Variable `json:"variables"`
        }
        _, err = c.github.Do(c.ctx, req, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list repository variables: %w", err)
        }</span>

        <span class="cov0" title="0">return response.Variables, nil</span>
}

func (c *Client) CreateOrUpdateOrgVariable(org string, variable *Variable) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("orgs/%s/actions/variables/%s", org, variable.Name)
        req, err := c.github.NewRequest("PATCH", url, variable)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create/update organization variable: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Client) CreateOrUpdateRepoVariable(owner, repo string, variable *Variable) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/actions/variables/%s", owner, repo, variable.Name)
        req, err := c.github.NewRequest("PATCH", url, variable)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create/update repository variable: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Client) DeleteOrgVariable(org, variableName string) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("orgs/%s/actions/variables/%s", org, variableName)
        req, err := c.github.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete organization variable: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Client) DeleteRepoVariable(owner, repo, variableName string) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/actions/variables/%s", owner, repo, variableName)
        req, err := c.github.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete repository variable: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Dependabot secrets methods
func (c *Client) ListOrgDependabotSecrets(org string) ([]*github.Secret, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := c.github.NewRequest("GET", fmt.Sprintf("orgs/%s/dependabot/secrets", org), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var response struct {
                Secrets []*github.Secret `json:"secrets"`
        }
        _, err = c.github.Do(c.ctx, req, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list organization Dependabot secrets: %w", err)
        }</span>

        <span class="cov0" title="0">return response.Secrets, nil</span>
}

func (c *Client) ListRepoDependabotSecrets(owner, repo string) ([]*github.Secret, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := c.github.NewRequest("GET", fmt.Sprintf("repos/%s/%s/dependabot/secrets", owner, repo), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var response struct {
                Secrets []*github.Secret `json:"secrets"`
        }
        _, err = c.github.Do(c.ctx, req, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list repository Dependabot secrets: %w", err)
        }</span>

        <span class="cov0" title="0">return response.Secrets, nil</span>
}

func (c *Client) CreateOrUpdateOrgDependabotSecret(org string, secret *github.EncryptedSecret) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encryption, err := c.GetOrgDependabotPublicKey(org)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encryptedSecret, err := encryption.CreateEncryptedSecret(secret.Name, secret.EncryptedValue)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("orgs/%s/dependabot/secrets/%s", org, secret.Name)
        req := struct {
                EncryptedValue string `json:"encrypted_value"`
                KeyID          string `json:"key_id"`
        }{
                EncryptedValue: encryptedSecret.EncryptedValue,
                KeyID:          encryptedSecret.KeyID,
        }

        httpReq, err := c.github.NewRequest("PUT", url, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, httpReq, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create/update organization Dependabot secret: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Client) CreateOrUpdateRepoDependabotSecret(owner, repo string, secret *github.EncryptedSecret) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encryption, err := c.GetRepoDependabotPublicKey(owner, repo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encryptedSecret, err := encryption.CreateEncryptedSecret(secret.Name, secret.EncryptedValue)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/dependabot/secrets/%s", owner, repo, secret.Name)
        req, err := c.github.NewRequest("PUT", url, encryptedSecret)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create/update repository Dependabot secret: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Client) DeleteOrgDependabotSecret(org, secretName string) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("orgs/%s/dependabot/secrets/%s", org, secretName)
        req, err := c.github.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete organization Dependabot secret: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Client) DeleteRepoDependabotSecret(owner, repo, secretName string) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/dependabot/secrets/%s", owner, repo, secretName)
        req, err := c.github.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete repository Dependabot secret: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Environment secrets methods
func (c *Client) GetEnvPublicKey(owner, repo, environment string) (*github.PublicKey, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/environments/%s/secrets/public-key", owner, repo, environment)
        req, err := c.github.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">key := &amp;github.PublicKey{}
        _, err = c.github.Do(c.ctx, req, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get environment public key: %w", err)
        }</span>
        <span class="cov0" title="0">return key, nil</span>
}

func (c *Client) ListEnvSecrets(owner, repo, environment string) ([]*github.Secret, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/environments/%s/secrets", owner, repo, environment)
        req, err := c.github.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var secrets struct {
                Secrets []*github.Secret `json:"secrets"`
        }
        _, err = c.github.Do(c.ctx, req, &amp;secrets)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list environment secrets: %w", err)
        }</span>
        <span class="cov0" title="0">return secrets.Secrets, nil</span>
}

func (c *Client) CreateOrUpdateEnvSecret(owner, repo, environment string, secret *github.EncryptedSecret) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">key, err := c.GetEnvPublicKey(owner, repo, environment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">decodedKey, err := base64.StdEncoding.DecodeString(*key.Key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode public key: %w", err)
        }</span>

        <span class="cov0" title="0">var publicKey [32]byte
        copy(publicKey[:], decodedKey)

        encryptedBytes, err := box.SealAnonymous(nil, []byte(secret.EncryptedValue), &amp;publicKey, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encrypt secret: %w", err)
        }</span>

        <span class="cov0" title="0">req := struct {
                EncryptedValue string `json:"encrypted_value"`
                KeyID          string `json:"key_id"`
        }{
                EncryptedValue: base64.StdEncoding.EncodeToString(encryptedBytes),
                KeyID:          *key.KeyID,
        }

        url := fmt.Sprintf("repos/%s/%s/environments/%s/secrets/%s", owner, repo, environment, secret.Name)
        httpReq, err := c.github.NewRequest("PUT", url, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, httpReq, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create/update environment secret: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Client) DeleteEnvSecret(owner, repo, environment, name string) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/environments/%s/secrets/%s", owner, repo, environment, name)
        req, err := c.github.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete environment secret: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Environment variables methods
func (c *Client) ListEnvironmentVariables(owner, repo, environment string) ([]*Variable, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/environments/%s/variables", owner, repo, environment)
        req, err := c.github.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var response struct {
                Variables []*Variable `json:"variables"`
        }
        _, err = c.github.Do(c.ctx, req, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list environment variables: %w", err)
        }</span>

        <span class="cov0" title="0">return response.Variables, nil</span>
}

func (c *Client) CreateOrUpdateEnvironmentVariable(owner, repo, environment string, variable *Variable) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/environments/%s/variables/%s", owner, repo, environment, variable.Name)
        req, err := c.github.NewRequest("PUT", url, variable)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create/update environment variable: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Client) DeleteEnvironmentVariable(owner, repo, environment, name string) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/environments/%s/variables/%s", owner, repo, environment, name)
        req, err := c.github.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete environment variable: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Wrappers for environment variable methods to match test expectations
func (c *Client) ListEnvVariables(owner, repo, environment string) ([]*Variable, error) <span class="cov0" title="0">{
        return c.ListEnvironmentVariables(owner, repo, environment)
}</span>

func (c *Client) CreateOrUpdateEnvVariable(owner, repo, environment string, variable *Variable) error <span class="cov0" title="0">{
        return c.CreateOrUpdateEnvironmentVariable(owner, repo, environment, variable)
}</span>

func (c *Client) DeleteEnvVariable(owner, repo, environment, name string) error <span class="cov0" title="0">{
        return c.DeleteEnvironmentVariable(owner, repo, environment, name)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "fmt"

        "github.com/google/go-github/v45/github"
)

// ListRepositoriesByProperty returns all repositories in an organization that have a specific custom property value
func (c *Client) ListRepositoriesByProperty(org, propertyName, propertyValue string) ([]*github.Repository, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate required parameters
        <span class="cov0" title="0">if org == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("organization name cannot be empty")
        }</span>
        <span class="cov0" title="0">if propertyName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("property_name cannot be empty")
        }</span>
        <span class="cov0" title="0">if propertyValue == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("property value cannot be empty")
        }</span>

        <span class="cov0" title="0">var matchingRepos []*github.Repository
        page := 1

        // Use the custom properties API to get repositories with the specific property value
        for </span><span class="cov0" title="0">{
                url := fmt.Sprintf("orgs/%s/properties/values?property_name=%s&amp;value=%s&amp;page=%d&amp;per_page=100",
                        org, propertyName, propertyValue, page)

                req, err := c.github.NewRequest("GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create request: %w", err)
                }</span>

                <span class="cov0" title="0">var response struct {
                        Repositories []struct {
                                Name string `json:"name"`
                        } `json:"repositories"`
                        HasNextPage bool `json:"has_next_page"`
                }
                _, err = c.github.Do(c.ctx, req, &amp;response)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get repositories by property: %w", err)
                }</span>

                // Get full repository objects for each matching repository
                <span class="cov0" title="0">for _, repoInfo := range response.Repositories </span><span class="cov0" title="0">{
                        repo, _, err := c.github.Repositories.Get(c.ctx, org, repoInfo.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to get repository %s: %w", repoInfo.Name, err)
                        }</span>
                        <span class="cov0" title="0">matchingRepos = append(matchingRepos, repo)</span>
                }

                <span class="cov0" title="0">if !response.HasNextPage </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">page++</span>
        }

        <span class="cov0" title="0">return matchingRepos, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "crypto/rand"
        "encoding/base64"
        "fmt"

        "github.com/google/go-github/v45/github"
        "golang.org/x/crypto/nacl/box"
)

// SecretEncryption handles the encryption of secrets using GitHub's public key
type SecretEncryption struct {
        KeyID     string
        PublicKey []byte
}

// GetOrgPublicKey fetches the public key for encrypting organization secrets
func (c *Client) GetOrgPublicKey(org string) (*SecretEncryption, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("orgs/%s/actions/secrets/public-key", org)
        if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetOrgPublicKey creating request for URL: %s\n", url)
        }</span>
        <span class="cov0" title="0">req, err := c.github.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var key struct {
                KeyID string `json:"key_id"`
                Key   string `json:"key"`
        }
        if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetOrgPublicKey sending request: %s %s\n", req.Method, req.URL.String())
        }</span>
        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, &amp;key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get organization public key: %w", err)
        }</span>
        <span class="cov0" title="0">if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetOrgPublicKey got response: KeyID=%s, Key=%s\n", key.KeyID, key.Key)
        }</span>

        <span class="cov0" title="0">publicKey, err := base64.StdEncoding.DecodeString(key.Key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode public key: %w", err)
        }</span>
        <span class="cov0" title="0">if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetOrgPublicKey decoded key length: %d\n", len(publicKey))
        }</span>

        <span class="cov0" title="0">return &amp;SecretEncryption{
                KeyID:     key.KeyID,
                PublicKey: publicKey,
        }, nil</span>
}

// GetRepoPublicKey fetches the public key for encrypting repository secrets
func (c *Client) GetRepoPublicKey(owner, repo string) (*SecretEncryption, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/actions/secrets/public-key", owner, repo)
        if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetRepoPublicKey creating request for URL: %s\n", url)
        }</span>
        <span class="cov0" title="0">req, err := c.github.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var key struct {
                KeyID string `json:"key_id"`
                Key   string `json:"key"`
        }
        if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetRepoPublicKey sending request: %s %s\n", req.Method, req.URL.String())
        }</span>
        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, &amp;key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get repository public key: %w", err)
        }</span>
        <span class="cov0" title="0">if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetRepoPublicKey got response: KeyID=%s, Key=%s\n", key.KeyID, key.Key)
        }</span>

        <span class="cov0" title="0">publicKey, err := base64.StdEncoding.DecodeString(key.Key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode public key: %w", err)
        }</span>
        <span class="cov0" title="0">if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetRepoPublicKey decoded key length: %d\n", len(publicKey))
        }</span>

        <span class="cov0" title="0">return &amp;SecretEncryption{
                KeyID:     key.KeyID,
                PublicKey: publicKey,
        }, nil</span>
}

// GetOrgDependabotPublicKey fetches the public key for encrypting organization Dependabot secrets
func (c *Client) GetOrgDependabotPublicKey(org string) (*SecretEncryption, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("orgs/%s/dependabot/secrets/public-key", org)
        if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetOrgDependabotPublicKey creating request for URL: %s\n", url)
        }</span>
        <span class="cov0" title="0">req, err := c.github.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var key struct {
                KeyID string `json:"key_id"`
                Key   string `json:"key"`
        }
        if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetOrgDependabotPublicKey sending request: %s %s\n", req.Method, req.URL.String())
        }</span>
        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, &amp;key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get org dependabot public key: %w", err)
        }</span>
        <span class="cov0" title="0">if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetOrgDependabotPublicKey got response: KeyID=%s, Key=%s\n", key.KeyID, key.Key)
        }</span>

        <span class="cov0" title="0">publicKey, err := base64.StdEncoding.DecodeString(key.Key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode public key: %w", err)
        }</span>
        <span class="cov0" title="0">if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetOrgDependabotPublicKey decoded key length: %d\n", len(publicKey))
        }</span>

        <span class="cov0" title="0">return &amp;SecretEncryption{
                KeyID:     key.KeyID,
                PublicKey: publicKey,
        }, nil</span>
}

// GetRepoDependabotPublicKey fetches the public key for encrypting repository Dependabot secrets
func (c *Client) GetRepoDependabotPublicKey(owner, repo string) (*SecretEncryption, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/dependabot/secrets/public-key", owner, repo)
        if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetRepoDependabotPublicKey creating request for URL: %s\n", url)
        }</span>
        <span class="cov0" title="0">req, err := c.github.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var key struct {
                KeyID string `json:"key_id"`
                Key   string `json:"key"`
        }
        if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetRepoDependabotPublicKey sending request: %s %s\n", req.Method, req.URL.String())
        }</span>
        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, &amp;key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get repo dependabot public key: %w", err)
        }</span>
        <span class="cov0" title="0">if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetRepoDependabotPublicKey got response: KeyID=%s, Key=%s\n", key.KeyID, key.Key)
        }</span>

        <span class="cov0" title="0">publicKey, err := base64.StdEncoding.DecodeString(key.Key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode public key: %w", err)
        }</span>
        <span class="cov0" title="0">if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetRepoDependabotPublicKey decoded key length: %d\n", len(publicKey))
        }</span>

        <span class="cov0" title="0">return &amp;SecretEncryption{
                KeyID:     key.KeyID,
                PublicKey: publicKey,
        }, nil</span>
}

// GetEnvironmentPublicKey fetches the public key for encrypting environment secrets
func (c *Client) GetEnvironmentPublicKey(owner, repo, environment string) (*SecretEncryption, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/environments/%s/secrets/public-key", owner, repo, environment)
        if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetEnvironmentPublicKey creating request for URL: %s\n", url)
        }</span>
        <span class="cov0" title="0">req, err := c.github.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var key struct {
                KeyID string `json:"key_id"`
                Key   string `json:"key"`
        }
        if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetEnvironmentPublicKey sending request: %s %s\n", req.Method, req.URL.String())
        }</span>
        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, &amp;key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get environment public key: %w", err)
        }</span>
        <span class="cov0" title="0">if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetEnvironmentPublicKey got response: KeyID=%s, Key=%s\n", key.KeyID, key.Key)
        }</span>

        <span class="cov0" title="0">publicKey, err := base64.StdEncoding.DecodeString(key.Key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode public key: %w", err)
        }</span>
        <span class="cov0" title="0">if Verbose </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] GetEnvironmentPublicKey decoded key length: %d\n", len(publicKey))
        }</span>

        <span class="cov0" title="0">return &amp;SecretEncryption{
                KeyID:     key.KeyID,
                PublicKey: publicKey,
        }, nil</span>
}

// EncryptSecret encrypts a secret value using libsodium's sealed box
func (s *SecretEncryption) EncryptSecret(secret string) (string, error) <span class="cov0" title="0">{
        if len(s.PublicKey) != 32 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid public key length: expected 32 bytes, got %d", len(s.PublicKey))
        }</span>

        <span class="cov0" title="0">var publicKey [32]byte
        copy(publicKey[:], s.PublicKey)

        encrypted, err := box.SealAnonymous(nil, []byte(secret), &amp;publicKey, rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encrypt secret: %w", err)
        }</span>

        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString(encrypted), nil</span>
}

// CreateEncryptedSecret creates an EncryptedSecret with the given name and encrypted value
func (s *SecretEncryption) CreateEncryptedSecret(name, value string) (*github.EncryptedSecret, error) <span class="cov0" title="0">{
        encryptedValue, err := s.EncryptSecret(value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;github.EncryptedSecret{
                Name:           name,
                KeyID:          s.KeyID,
                EncryptedValue: encryptedValue,
        }, nil</span>
}

// CreateOrUpdateEnvironmentSecret creates or updates an environment-level secret
func (c *Client) CreateOrUpdateEnvironmentSecret(owner, repo, environment string, secret *github.EncryptedSecret) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encryption, err := c.GetEnvironmentPublicKey(owner, repo, environment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">encryptedSecret, err := encryption.CreateEncryptedSecret(secret.Name, secret.EncryptedValue)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/environments/%s/secrets/%s", owner, repo, environment, secret.Name)
        req := struct {
                EncryptedValue string `json:"encrypted_value"`
                KeyID          string `json:"key_id"`
        }{
                EncryptedValue: encryptedSecret.EncryptedValue,
                KeyID:          encryptedSecret.KeyID,
        }

        httpReq, err := c.github.NewRequest("PUT", url, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, httpReq, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create/update environment secret: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteEnvironmentSecret deletes an environment-level secret
func (c *Client) DeleteEnvironmentSecret(owner, repo, environment, name string) error <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/environments/%s/secrets/%s", owner, repo, environment, name)
        req, err := c.github.NewRequest("DELETE", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = c.github.Do(c.ctx, req, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete environment secret: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListEnvironmentSecrets lists all secrets available in an environment
func (c *Client) ListEnvironmentSecrets(owner, repo, environment string) ([]*github.Secret, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/environments/%s/secrets", owner, repo, environment)
        req, err := c.github.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">var response struct {
                Secrets []*github.Secret `json:"secrets"`
        }
        _, err = c.github.Do(c.ctx, req, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list environment secrets: %w", err)
        }</span>

        <span class="cov0" title="0">return response.Secrets, nil</span>
}

// GetEnvironmentSecret gets a single environment-level secret
func (c *Client) GetEnvironmentSecret(owner, repo, environment, name string) (*github.Secret, error) <span class="cov0" title="0">{
        if err := c.ensureValidToken(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("repos/%s/%s/environments/%s/secrets/%s", owner, repo, environment, name)
        req, err := c.github.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">secret := &amp;github.Secret{}
        _, err = c.github.Do(c.ctx, req, secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get environment secret: %w", err)
        }</span>

        <span class="cov0" title="0">return secret, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
